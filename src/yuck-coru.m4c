/* -*- c -*- */
#if defined HAVE_CONFIG_H
# include "config.h"
#endif	/* HAVE_CONFIG_H */
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
ifdef([YUCK_HEADER], [#include "YUCK_HEADER"
])dnl

#if defined __INTEL_COMPILER
# pragma warning (disable:177)
# pragma warning (disable:111)
#elif defined __GNUC__
# if __GNUC__ > 4 || __GNUC__ == 4 &&  __GNUC_MINOR__ >= 6
#  pragma GCC diagnostic push
# endif	 /* GCC version */
# pragma GCC diagnostic ignored "-Wunused-label"
# pragma GCC diagnostic ignored "-Wunused-variable"
#endif	/* __INTEL_COMPILER */


static inline bool
yuck_streqp(const char *s1, const char *s2)
{
	return !strcmp(s1, s2);
}

static enum yuck_cmds_e yuck_parse_cmd(const char *cmd)
{
	if (0) {
		;
	}foreachq([C], yuck_cmds(), [ else if (yuck_streqp(cmd, "yuck_cmd_string(C)")) {
		return yuck_cmd(C);
	}]) else {
		/* error here? */
		fprintf(stderr, "YUCK_UMB: invalid command `%s'\n\
Try `--help' for a list of commands.\n", cmd);
	}
	return (enum yuck_cmds_e)-1;
}

static void yuck_auto_usage(enum yuck_cmds_e cmd)
{
	switch (cmd) {
	default:
	YUCK_NONE:
		if (!YUCK_NCMDS) {
			puts("Usage: YUCK_UMB [[OPTION]]... defn([YUCK_UMB.POSARG])");
		} else {
			puts("Usage: YUCK_UMB [[OPTION]]... COMMAND defn([YUCK_UMB.POSARG])");
		}
ifelse(yuck_umb_desc(), [], [], [dnl
		puts("\n\
yuck_C_literal(yuck_umb_desc())");
])dnl
		break;
foreachq([C], yuck_cmds(), [
	case yuck_cmd(C):
		puts("Usage: YUCK_UMB [[OPTION]]... yuck_cmd_string(C) yuck_cmd_posarg(C)");
ifelse(yuck_cmd_desc(C), [], [], [dnl
		puts("\n\
yuck_C_literal(yuck_cmd_desc(C))");
])dnl
		break;
])
	}
	return;
}

static void yuck_auto_help(enum yuck_cmds_e cmd)
{
	yuck_auto_usage(cmd);

ifelse(yuck_cmds(), [], [], [dnl
	if (cmd == YUCK_NONE) {
		/* also output a list of commands */
		puts("\nCOMMAND may be one of:\n\
foreachq([C], yuck_cmds(), [  yuck_cmd_string(C)\n\
])");
	}
])dnl

	switch (cmd) {
	default:foreachq([C], yuck_umbcmds(), [
	case yuck_cmd(C):
		puts("\n\
foreachq([I], yuck_idents(C), [dnl
yuck_C_literal(yuck_option_help_line(defn([I]), defn([C])))[]dnl
])dnl
");
		break;
])
	}
	return;
}

static void yuck_auto_version(enum yuck_cmds_e cmd)
{
	switch (cmd) {
	default:
ifdef([YUCK_VER], [dnl
		puts("YUCK_UMB YUCK_VER");
], [dnl
#if defined PACKAGE_VERSION
		puts("YUCK_UMB " PACKAGE_VERSION);
#elif defined VERSION
		puts("YUCK_UMB " VERSION);
#else  /* !PACKAGE_VERSION, !VERSION */
		puts("YUCK_UMB unknown version");
#endif	/* PACKAGE_VERSION */
])dnl
		break;
	}
	return;
}

/* for multi-args */
static const char **yuck_append(const char **prev, size_t n, const char *val)
{
	if (!(n % 16U)) {
		/* resize */
		prev = realloc(prev, (n + 16U) * sizeof(*prev));
	}
	prev[[n]] = val;
	return prev;
}


int yuck_parse(struct yuck_s *restrict tgt, int argc, char *const argv[[]])
{
	const char *op;
	char **args;
	int i;

	/* we'll have at most this many args */
	memset(tgt, 0, sizeof(*tgt));
	tgt->args = args = calloc(argc, sizeof(*tgt->args));
	tgt->nargs = 0U;
	tgt->cmd = YUCK_NONE;
	for (i = 1; i < argc; i++) {
		op = argv[[i]];

		switch (*op) {
		case '-':
			/* could be an option */
			switch (*++op) {
			case '-':
				if (*++op == '\0') {
					yield(dashdash);
					break;
				}
				yield(longopt, op);
				break;
			default:
				/* could be glued into one */
				for (; *op; op++) {
					yield(shortopt, *op);
				}
				break;
			}
			break;
		default:
			yield(arg, op);
			break;
		}
	}
	return 0;

	coroutine(longopt)
	{
		/* split into option and arg part */
		char *arg;

		if ((arg = strchr(op, '=')) != NULL) {
			/* \nul this one out */
			*arg++ = '\0';
		}

		switch (tgt->cmd) {
		default:
			yield(yuck_cmd()[_longopt]);
			break;
		foreachq([C], yuck_cmds(), [case yuck_cmd(C):
			yield(yuck_cmd(C)[_longopt]);
			break;
		])}
		resume;

		foreachq([C], yuck_umbcmds(), [coroutine(yuck_cmd(C)[_longopt])
		{
			if (0) {
				;
			}foreachq([opt], yuck_longs(C), [ else if (yuck_streqp(op, "opt")) {
				yuck_iftype(opt, C, 
					[flag], [tgt->yuck_slot(opt, C)++],
					[arg], [tgt->yuck_slot(opt, C) = arg ?: argv[[++i]]],
					[arg,opt], [tgt->yuck_slot(opt, C) = arg ?: YUCK_OPTARG_NONE],
					[arg,mul], [tgt->yuck_slot(opt, C) =
					yuck_append(
						tgt->yuck_slot(opt, C), tgt->yuck_cnt_slot(opt, C)++,
						arg ?: argv[[++i]])],
					[arg,mul,opt], [tgt->yuck_slot(opt, C) =
					yuck_append(
						tgt->yuck_slot(opt, C), tgt->yuck_cnt_slot(opt, C)++,
						arg ?: YUCK_OPTARG_NONE)],
					[auto], [/* invoke auto action and exit */
				yuck_auto_[]yuck_canon(opt, C)(tgt->cmd);
				resume_at(success)]);
			}]) else {
				ifelse(C, [],
				       [/* grml */
				fprintf(stderr, "YUCK_UMB: unrecognized option `--%s'\n", op);
				resume_at(failure);],
				       [resume_at(yuck_cmd()[_longopt]);])
			}
			resume;
		}
		])
	}

	coroutine(shortopt)
	{
		const char *arg = op + 1U;

		switch (tgt->cmd) {
		default:
			yield(yuck_cmd()[_shortopt]);
			break;
		foreachq([C], yuck_cmds(), [case yuck_cmd(C):
			yield(yuck_cmd(C)[_shortopt]);
			break;
		])}
		resume;

		foreachq([C], yuck_umbcmds(), [coroutine(yuck_cmd(C)[_shortopt])
		{
			switch (*op) {
			default:
				divert(1);
				fprintf(stderr, "YUCK_UMB: invalid option -%c\n", *op);
				resume_at(failure);

ifelse(quote(translit(yuck_shorts, [0123465789])), quote(yuck_shorts), [], [
				/* [yuck_shorts()] (= yuck_shorts())
				 * has numerals as shortopts
				 * don't allow literal treatment of numerals */divert(-1)])
			case '0' ... '9':;
				/* literal treatment of numeral */
				resume_at(arg);

				divert(2);
				resume_at(yuck_cmd()[_shortopt]);

				divert(0);
				ifelse(C, [], [select_divert(1)], [select_divert(2)])dnl

			foreachq([opt], yuck_shorts(C), [case 'opt':
				yuck_iftype(opt, C, 
					[flag], [tgt->yuck_slot(opt, C)++],
					[arg], [tgt->yuck_slot(opt, C) = *arg
						? (op += strlen(arg), arg)
						: argv[[++i]]],
					[arg,opt], [tgt->yuck_slot(opt, C) = *arg
						? (op += strlen(arg), arg)
						: YUCK_OPTARG_NONE],
					[arg,mul], [tgt->yuck_slot(opt, C) =
					yuck_append(
						tgt->yuck_slot(opt, C), tgt->yuck_cnt_slot(opt, C)++,
						*arg ? (op += strlen(arg), arg) : argv[[++i]])],
					[arg,mul,opt], [tgt->yuck_slot(opt, C) =
					yuck_append(
						tgt->yuck_slot(opt, C), tgt->yuck_cnt_slot(opt, C)++,
						*arg ? (op += strlen(arg), arg) : YUCK_OPTARG_NONE)],
					[auto], [/* invoke auto action and exit */
				yuck_auto_[]yuck_canon(opt, C)(tgt->cmd);
				resume_at(success)]);
				break;
			])}
			resume;
		}
		])
	}

	coroutine(arg)
	{
		if (tgt->cmd || !YUCK_NCMDS) {
			args[[tgt->nargs++]] = argv[[i]];
		} else {
			/* ah, might be an arg then */
			if ((tgt->cmd = yuck_parse_cmd(op)) > YUCK_NCMDS) {
				return -1;
			}
		}
		resume;
	}

	coroutine(dashdash)
	{
		/* dashdash loop, pile everything on tgt->args
		 * don't check for subcommands either, this is in accordance to
		 * the git tool which won't accept commands after -- */
		for (i++; i < argc; i++) {
			args[[tgt->nargs++]] = argv[[i]];
		}
		return 0;
	}

	coroutine(failure)
	{
		exit(EXIT_FAILURE);
	}

	coroutine(success)
	{
		exit(EXIT_SUCCESS);
	}
}

void yuck_free(struct yuck_s *restrict tgt)
{
	if (tgt->args != NULL) {
		/* free despite const qualifier */
		free((char*)NULL + ((const char*)tgt->args - (char*)NULL));
	}
	return;
}

#if defined __INTEL_COMPILER
# pragma warning (default:177)
# pragma warning (default:111)
#elif defined __GNUC__
# if __GNUC__ > 4 || __GNUC__ == 4 &&  __GNUC_MINOR__ >= 6
#  pragma GCC diagnostic pop
# endif	 /* GCC version */
#endif	/* __INTEL_COMPILER */
